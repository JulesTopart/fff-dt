#version 430

#pragma once
#include "../common/uniforms.comp"
#include "../common/constants.comp"
#include "../common/buffers.comp"
#include "../common/nns.comp"
#include "sph.kernels.comp"
#include "boundary.comp"
#include "pbf.comp"
//#include "pbs.comp"
#include "heat.comp"

layout (local_size_x = PTHREAD) in;

uniform uint stage;
void exec(uint index, uint kernel);

uniform int fluid_emitter_color = 0; //A or B
uniform int retract = 0;
// XPBD_Main
void main() {
	uint index = gl_GlobalInvocationID.x;
	if (index >= u_numParticles + u_numEmitter) return;
	
	if(retract == 1){
		uint i = index;
		vec4 nozzle = u_emitterTransform * vec4(0,0,0,1);
		if (is_fluid(index) && ((b_pi.z > nozzle.z+3 && distance(nozzle.xy, b_pi.xy) < 10))){
			phase(index) = UNUSED;
			ssbo_predicted_position[index] = vec4(1000,1000,1000,1); //end of buffer
		}
	}

	if(phase(index) == BOUNDARY + 1 && index < u_numParticles && stage >= 2){ //fix copy error see commit 02/05/2025
		uint i = index;
		vec3 newPos = vec3(u_emitterTransform * vec4(b_last_xi.xyz, 1.0));
		b_vi.xyz = (newPos - b_xi.xyz)/u_dt;
		b_pi.xyz = b_xi.xyz = newPos; //force boudary
		return;
	}
	
	if(phase(index) == BOUNDARY + 2 && index < u_numParticles && stage >= 2){ 
		uint i = index;
		vec3 newPos = vec3(u_bunnyTransform * vec4(b_last_xi.xyz, 1.0));
		b_vi.xyz = (newPos - b_xi.xyz)/u_dt;
		b_pi.xyz = b_xi.xyz = newPos; //force boudary
		return;
	}


	//sink
	/*
	if(phase(index) < BOUNDARY && index < u_numParticles && stage >= 2){ //fix copy error see commit 02/05/2025
		uint i = index;
		if(length(b_pi.xy) > 5){ 
			phase(i) = UNUSED;
			//atomicCounterIncrement(uCounter); //delete particle in particle count
			b_vi.xyz *= 0;
			b_pi.xyz *= 0; //force boudary
		}
	}
	*/

	exec(index, stage);

}

void spawnParticle(uint i){
	if (i >= u_numParticles) {
		uint emmiterID = i - u_numParticles;

		b_xi.w = b_pi.w = 1;
		b_xi.xyz = b_pi.xyz = b_last_xi.xyz = vec3(0,0,5) + (u_emitterTransform * vec4(ssbo_emitter_positions[emmiterID].xyz,1.0)).xyz;
		
		b_rho_i = u_rho0;
		b_vi = vec4(0, 0, 0.0, 0);
		b_Ti = 275.15 + 220;
		b_dTi = 0.0;

		uint newphase = fluid_emitter_color == 0 ? FLUID_A : FLUID_B;

		ssbo_meta[i] = uvec4(newphase, getBinIndex(ssbo_position[i].xyz), i, 0); //phase, binindex, id , sortedID
	}
}

void copyBuffers(uint i){
	uint bin = getBinIndex(ssbo_position[i].xyz);
	atomicAdd(ssbo_bins[bin].count, 1);

	ssbo_copy[i].last_position		= ssbo_last_position[i];
	ssbo_copy[i].position			= ssbo_position[i];
	ssbo_copy[i].predicted_position = ssbo_predicted_position[i];
	ssbo_copy[i].position_correction = ssbo_position_correction[i];
	ssbo_copy[i].velocity			= ssbo_velocity[i];
	ssbo_copy[i].density			= ssbo_density[i];
	ssbo_copy[i].temperature		= ssbo_temperature[i];
	//ssbo_copy[i].F = ssbo_F[i];
	//ssbo_copy[i].L = ssbo_L[i];
	ssbo_copy[i].meta.x = ssbo_meta[i].x;
	ssbo_copy[i].meta.y = bin;
	ssbo_copy[i].meta.z = ssbo_meta[i].z;
	ssbo_copy[i].meta.w = 0;
	
}

void sortBuffers(uint i){
	uint bin = ssbo_copy[i].meta.y;//getBinIndex(ssbo_copy[i].position.xyz);
	uint newID = atomicAdd(ssbo_bins[bin].index, -1) -1;
	uvec4 m = ssbo_copy[i].meta;
	uint   origID = m.z;

	ssbo_last_position[newID]		= ssbo_copy[i].last_position;
	ssbo_position[newID]			= ssbo_copy[i].position;
	ssbo_predicted_position[newID]	= ssbo_copy[i].predicted_position;
	ssbo_position_correction[newID] = ssbo_copy[i].position_correction;
	ssbo_velocity[newID]			= ssbo_copy[i].velocity;
	ssbo_density[newID]				= ssbo_copy[i].density;
	ssbo_temperature[newID]			= ssbo_copy[i].temperature;
	
	//ssbo_F[newID]					= ssbo_copy[i].F; 
	//ssbo_L[newID]					= ssbo_copy[i].L; 

	ssbo_meta[newID].x			= ssbo_copy[i].meta.x;
	ssbo_meta[newID].y			= bin;
	ssbo_meta[newID].z			= ssbo_copy[i].meta.z;
	ssbo_meta[origID].w = newID;
}

void exec(uint index, uint kernel){
	uint i = index;
	if(index < u_numParticles)
		switch(kernel){
		case 0: 
			copyBuffers(index);
			break;
		case 1: 
			sortBuffers(index);
			break;
		case 2:
			if(is_fluid(index))
				pbf_step(index, 0);
			//else if(is_solid(index)){
				//pbs_step(index, 3);
				//pbs_step(index, 0);
				//b_vi *=0;
				//ssbo_density[index] = boundary_computePseudoMass(index);
			//}
			else// if(phase(index) >= BOUNDARY)
				ssbo_density[index] = boundary_computePseudoMass(index);

			if(phase(index) < BOUNDARY) b_dTi = computeTemperatureDelta(index) * u_dt;

			break;
		case 3: 
			if(is_fluid(index))
				pbf_step(index, 1);
			//else if(is_solid(index))
				//pbs_step(index, 1);

			if(phase(index) < BOUNDARY) {
				float t = ssbo_temperature[index].x;
				if(phase(index) < BOUNDARY) t += ssbo_temperature[index].y;
				if(!isnan(t) && t < 1000 && t > 275) ssbo_temperature[index].x = t;
				ssbo_temperature[index].y = 0;

				/**/
				if(isnan(ssbo_temperature[index].x)) ssbo_temperature[index].x = is_fluid(index) ? 275 + 220 : 275;

				if(is_fluid(index) && ssbo_temperature[index].x < 275+80){ 
					if(phase(index) == FLUID_A) phase(index) = SOLID_A;
					else if(phase(index) == FLUID_B) return;
					//else if(phase(index) == FLUID_B) phase(index) = SOLID_B;

					ssbo_last_position[index] = ssbo_position[index] = ssbo_predicted_position[index]; // Fix rest position
					
					b_vi *=0;
				}
				else if(is_solid(index) && ssbo_temperature[index].x > 275+90) phase(index) = FLUID_A;
				/**/
			}
			break;
		case 4:
			if(is_fluid(index))
				pbf_step(index, 2);
			//else if(is_solid(index))
				//pbs_step(index, 2);

			break;
		case 5: 
			if(is_fluid(index))
				pbf_step(index, 3);
			//else if(is_solid(index))
				//pbs_step(index, 3);
			break;
		case 6: 
			if(is_fluid(index))
				pbf_step(index, 4);

			break;
		}
	else if(kernel == 8) spawnParticle(index);


}
