//? #version 430
#ifndef INCLUDE_MATH_GLSL
#define INCLUDE_MATH_GLSL

//?#include "../common/buffers.comp"

#define PI 3.14159265358979323846f

float tr(mat3 m){ //trace
    return m[0][0] + m[1][1] + m[2][2];
}

float det(mat3 m){ //determinant
    return determinant(m);
}

mat3 inverseTranspose(mat3 M) {
    return transpose(inverse(M));
}

mat3 pseudoInverse(mat3 A) {
    // Calculate the determinant
    float det = det(A);
    
    // Check if the determinant is non-zero (indicating the matrix is invertible)
    if (abs(det) > 1e-6) {
        // If invertible, calculate the inverse (same as before)
        return inverse(A);
    } else {
        // If not invertible, we calculate the pseudoinverse
        // Compute the squared Frobenius norm of the matrix
        float normSquared = dot(A[0], A[0]) + dot(A[1], A[1]) + + dot(A[2], A[2]);

        // If the matrix is near zero, return a zero matrix to avoid division by zero
        if (normSquared < 1e-6) {
            return mat3(0.0);
        }
        return transpose(A) / normSquared;
    }
}



float frobeniusNorm(mat3 matrix) {
    float sum = 0.0;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            sum += matrix[i][j] * matrix[i][j];
        }
    }
    return sqrt(sum);
}

float frobeniusNormSq(mat3 matrix) {
    float sum = 0.0;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            sum += matrix[i][j] * matrix[i][j];
        }
    }
    return sum;
}

// Quaternion multiplication
vec4 multiplyQuaternions(vec4 a, vec4 b)
{
	vec4 ans;
	ans.x = a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y;  // i
	ans.y = a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x;  // j
	ans.z = a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w;  // k
	ans.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;  // 1
	return ans;
}

// Convert angle-axis to quaternion
vec4 angleAxisToQuaternion(float angle, vec3 axis) {
	axis = normalize(axis);
	float halfAngle = angle * 0.5;
	float s = sin(halfAngle);
	return vec4(axis * s, cos(halfAngle));
}

// Convert quaternion to rotation matrix
mat3 quaternionToMatrix(vec4 q)
{
    float x = q.x, y = q.y, z = q.z, w = q.w;

    return mat3(
        vec3(1.0 - 2.0 * (y * y + z * z), 2.0 * (x * y + w * z), 2.0 * (x * z - w * y)),
        vec3(2.0 * (x * y - w * z), 1.0 - 2.0 * (x * x + z * z), 2.0 * (y * z + w * x)),
        vec3(2.0 * (x * z + w * y), 2.0 * (y * z - w * x), 1.0 - 2.0 * (x * x + y * y))
    );
}


mat3 matrixFromAxisAngle(vec3 axis, float angle) {
	axis = normalize(axis);
	float c = cos(angle);
	float s = sin(angle);
	float t = 1.0 - c;


	float m00 = c + axis.x * axis.x * t;
	float m11 = c + axis.y * axis.y * t;
	float m22 = c + axis.z * axis.z * t;

	float tmp1 = axis.x * axis.y * t;
	float tmp2 = axis.z * s;
	float m10 = tmp1 + tmp2;
	float m01 = tmp1 - tmp2;
	tmp1 = axis.x * axis.z * t;
	tmp2 = axis.y * s;
	float m20 = tmp1 - tmp2;
	float m02 = tmp1 + tmp2;    
	tmp1 = axis.y * axis.z * t;
	tmp2 = axis.x * s;
	float m21 = tmp1 + tmp2;
	float m12 = tmp1 - tmp2;
	return mat3(m00, m01, m02, m10, m11, m12, m20, m21, m22);
}

// Main function to extract rotation
mat3 extractRotation(mat3 A, inout vec4 q, int maxIter = 200) {
    if(length(q) == 0.0) q = vec4(0.0, 0.0, 0.0, 1.0); // Identity quaternion

    for (int iter = 0; iter < maxIter; iter++) {
        mat3 R = quaternionToMatrix(q);
        float denom = abs(dot(R[0], A[0]) + dot(R[1], A[1]) + dot(R[2], A[2])) + 1.0e-9;
        vec3 omega = (cross(R[0], A[0]) + cross(R[1], A[1]) + cross(R[2], A[2])) / denom;
        
        float w2 = length(omega)*length(omega);
			if (w2 < 1.0e-9)
				break;

		float w = length(omega);

        // Update quaternion with the rotation represented by omega
        vec4 deltaQ = angleAxisToQuaternion(w, omega / w);
        q = multiplyQuaternions(deltaQ, q); // Apply deltaQ to current q
        q = normalize(q); // Normalize to maintain numerical stability
    }
    return quaternionToMatrix(q);
}


#endif// INCLUDE_MATHHLSL