#version 430

#pragma once
#include "../../common/shaders/graphics/colors.comp"
#include "../common/uniforms.comp"
#include "../common/constants.comp"
#include "../common/buffers.comp"
#include "../common/nns.comp"
#include "sph.kernels.comp" 

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout (rgba16f, binding = 0) writeonly uniform image2D u_output;

uniform int colorMode = 3;
uniform int colorMapSelection = 0;
uniform float offsetPlane = 0;

float interpolate(in vec3 position){
	float density = 0;

	OVERNNS
		float dist = distance(b_xj.xyz, position);
		if(dist > H) continue;
		float Wij = poly6(dist);

		if(is_fluid(j) || is_solid(j))
			density += mj * Wij*3.6;
	OVERNNS_END
	return density;
}

bool isBoundary(in vec3 position){
	bool result = false;

	OVERNNS
		float dist = distance(b_xj.xyz, position);
		if(dist > H*0.4) continue;

		if(phase(j) >= BOUNDARY)
			result = true;
	OVERNNS_END
	return result;
}


float interpolatePhase(in vec3 position){
	float est_phase = 0;

	OVERNNS
		float dist = distance(b_xj.xyz, position);
		if(dist > H) continue;
		float Wij = poly6(dist);

		if(is_fluid(j))
			est_phase -= mj * Wij;
		if(is_solid(j))
			est_phase += mj * Wij;
	OVERNNS_END
	return est_phase;
}

float interpolatePhaseAB(in vec3 position){
	float est_phaseA = 0;
	float est_phaseB = 0;
	float est_phaseNone = 0;

	OVERNNS
		float dist = distance(b_xj.xyz, position);
		if(dist > H) continue;
		float Wij = poly6(dist);

		if(phaseAB(j) == 0)
			est_phaseA += mj * Wij;
		else if(phaseAB(j) == 1)
			est_phaseB += mj * Wij;
		else 
			est_phaseNone += mj * Wij;
	OVERNNS_END

	if(est_phaseA > est_phaseB) 
		return 0.0;
	else 
		return 1.0;
}


float interpolateHeat(in vec3 position){
	float temp = 0;

	OVERNNS
		float dist = distance(b_xj.xyz, position);
		if(dist > H) continue;
		float Wij = poly6(dist);
		if(is_solid(j) || is_fluid(j)){
			temp += b_Tj * Wij*0.3; //pseudo mass, 
		}
	OVERNNS_END
	return temp;
}


uniform vec3 axis;
uniform vec3 offset;

void main(){
    ivec2 dims = imageSize(u_output).xy;
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy) + ivec2(0,-50);

	vec2 uv = vec2(pixel_coords) / vec2(dims);
	vec2 position = vec2(0);
	float temp = 0;
	float est_phase = 0;
	float density = 0;

	vec3 worldPos = vec3(0);
	if(axis == vec3(1,1,0)){
		uv.x = uv.x - 0.5f;
		uv.y = uv.y - 0.5f;
		position = uv * vec2(cst_domain.xy);
		worldPos = vec3(position.x, position.y, 0 + offsetPlane) + offset;

	}else if(axis == vec3(1,0,1)){
		uv.x = uv.x - 0.5f;
		position = uv * vec2(cst_domain.xz);
		worldPos = vec3(position.x, 0 + offsetPlane, position.y) + offset;

	}else if(axis == vec3(0,1,1)){
		uv.x = uv.x - 0.5f;
		position = uv * vec2(cst_domain.yz);
		worldPos = vec3(0 + offsetPlane, position.x, position.y) + offset;
	}



	float minValue = 0;
	float maxValue = 0;
	float value = 0;

	density = interpolate(worldPos);
	temp = interpolateHeat(worldPos);
	est_phase = interpolatePhase(worldPos);

	Palette palette = inferno;



	if(colorMapSelection == 0)
		palette = inferno;
	else if(colorMapSelection == 1)
		palette = blackbody;
	else if(colorMapSelection == 2)
		palette = plasma;
	else if(colorMapSelection == 3)
		palette = viridis;
	else if(colorMapSelection == 4)
		palette = warmcool;
	else if(colorMapSelection == 5)
		palette = parula;
	else if(colorMapSelection == 6)
		palette = jet;
		
	if(isBoundary(worldPos)){
		vec4 color = vec4(0.8, 0.8, 0.8, 1);
		imageStore(u_output, pixel_coords, color);
		return;
	}

	if(colorMode == 0){ // solid color

		vec3 color = vec3(0.8, 0.8, 0.8);
		vec3 colorA = vec3(0.8, 0.0, 0.0);
		vec3 colorB = vec3(0.0, 0.0, 0.8);

		float phaseAB = interpolatePhaseAB(worldPos);

		if(phaseAB == 0){
			color = colorA;
		}else if(phaseAB == 1){
			color = colorB;
		}

		imageStore(u_output, pixel_coords, vec4(color,density));
		return;
	}else if(colorMode == 1){ // bin index
		uint binI = getBinIndex(worldPos);
		imageStore(u_output, pixel_coords, vec4(randomColor(binI).rgb,density));
		return;
	}else if(colorMode == 2){ // density
		value = density;
		minValue = 1000 * u_rho0;
		maxValue =  1050 * u_rho0;
	}else if(colorMode == 3){ // Temperature
		value = temp;
		minValue = 275;
		maxValue =  275+200.0;
	}else if(colorMode == 4){ // Phase
		value = est_phase;
		minValue = -1;
		maxValue =  1;
		
	}else if(colorMode == 5){ // solid color
		value = temp;
		minValue = 275;
		maxValue =  275+300.0;
	}else if(colorMode == 6){ // solid color
		value = temp;
		minValue = 275;
		maxValue =  275+300.0;
	}

	imageStore(u_output, pixel_coords, vec4(colorMap(map(value,minValue,maxValue), palette).rgb, density));
	


	return;

}